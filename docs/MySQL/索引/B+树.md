# B+ Tree

先了解一下 B 树，

> #### B 树
>
> 一棵 n 阶 B 树，
> - 每个节点最多有 n 个子节点；
> - 除了根节点，每个非叶子节点最少有 ⌈n/2⌉ 个子节点；
> - 有 k 个子节点的非叶子节点包含 k-1 个元素；
> - 所有的叶子节点都在同一层。

> #### B+ 树
>
> 一棵 n 阶 B+ 树，
>
> - 有 k 个子节点的节点包含 k 个key；
> - 所有的非叶子节点可以看成是索引部分，节点中近含有其子节点中最大（或最小）的元素。
> - 所有的叶子节点包含了全部元素，且叶子节点按元素的大小顺序链接；






### 区别

#### 与自平衡二叉树（AVL 树、红黑树等）的比较
红黑树等自平衡二叉树也可以用来实现索引，但是文件系统和数据库系统普遍采用 B+ 树作为索引结构，因为

- 磁盘 I/O 次数少

    因为 B+ 树的非叶节点可以存储多个元素，有更多子树，相比于二叉树更加 “矮胖”，所以磁盘 I/O 次数更少。

- 磁盘预读特性

    为了减少磁盘 I/O 操作，磁盘往往不是严格按需读取，而是每次都会预读。预读过程中，磁盘进行顺序读取，顺序读取不需要进行磁盘寻道。每次会读取页的整数倍。

    操作系统一般将内存和磁盘分割成固定大小的块，每一块称为一页，内存与磁盘以页为单位交换数据。数据库系统将索引的一个节点的大小设置为页的大小，使得一次 I/O 就能完全载入一个节点。

#### 与 B 树的比较

- 磁盘 I/O 次数更少

    B+ 树的非叶节点只存储元素的索引，可以容纳更多索引值，比 B 树更加 “矮胖”。

- 查询性能更加稳定

    因为 B+ 树的非叶节点只存储元素的索引，所以查找任何元素都必须从根节点查找到叶节点，查找路径长度相同，所以每次查找效率都相当。

- 元素遍历效率高

    B 树在提高了磁盘 I/O 性能的同时并没有解决元素遍历效率低下的问题。B+ 树就是为了解决这个问题而产生的。因为所有元素都存储在叶节点中，B+ 树只要遍历叶节点就可以实现整棵树的遍历。而且在数据库中基于范围的查询是非常频繁的，而 B 树不支持这样的操作（或者说效率太低）。